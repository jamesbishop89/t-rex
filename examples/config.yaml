# T-Rex Trading System Configuration Example
# This file demonstrates all available configuration options for trading data reconciliation
# ========================================================================================

reconciliation:
  # KEYS SECTION
  # ------------
  # Define the key columns used to match trades between source and target systems
  # Can be a single key or multiple keys for composite matching
  keys: [trade_id, account_id]
  
  # FIELDS SECTION
  # --------------
  # Configure each field with optional mappings, transformations, and tolerances
  fields:
    
    # EXAMPLE 1: Trade price with PERCENTAGE tolerance (market volatility)
    - name: execution_price
      tolerance: "0.1%"  # Allow 0.1% difference in execution price
      
    # EXAMPLE 2: Share quantity with ABSOLUTE tolerance
    - name: quantity
      tolerance: 1.0  # Allow difference of 1 share
      
    # EXAMPLE 3: Commission rate with SMALL percentage tolerance
    - name: commission_rate
      tolerance: "0.01%"  # Allow 0.01% difference in commission rate
      
    # EXAMPLE 4: Trade status field with VALUE MAPPING
    - name: trade_status
      mapping:
        "New": "N"
        "Partially Filled": "PF"
        "Filled": "F"
        "Cancelled": "C"
        "Rejected": "R"
        "Pending": "P"
        "NULL": "Unknown"
        "": "Unknown"
        
    # EXAMPLE 5: Trade date field with TRANSFORMATION
    - name: trade_date
      transformation: "lambda x: x.strip().replace('/', '-')"
      
    # EXAMPLE 6: Net amount with TRANSFORMATION + TOLERANCE
    - name: net_amount
      transformation: "lambda x: round(float(x), 2)"
      tolerance: 0.01  # Allow 1 cent difference
      
    # EXAMPLE 7: Asset class with MAPPING + TRANSFORMATION
    - name: asset_class
      mapping:
        "Equity": "EQ"
        "Fixed Income": "FI"
        "Derivatives": "DV"
        "Foreign Exchange": "FX"
        "Commodities": "COM"
        "Alternative": "ALT"
      transformation: "lambda x: x.upper().strip()"
      
    # EXAMPLE 8: Market value with NULL handling
    - name: market_value
      mapping:
        "N/A": 0
        "NULL": 0
        "": 0
        "-": 0
      transformation: "lambda x: float(x) if x else 0"
      tolerance: 0.01
      
    # EXAMPLE 9: Settlement flag conversion
    - name: is_settled
      mapping:
        "Yes": True
        "No": False
        "Y": True
        "N": False
        "1": True
        "0": False
        "Settled": True
        "Pending": False
      
    # EXAMPLE 10: Currency amount with complex transformation
    - name: gross_amount
      transformation: "lambda x: float(x.replace('$', '').replace(',', '').replace('USD', '')) if isinstance(x, str) else float(x)"
      tolerance: "0.01%"
      
    # EXAMPLE 11: Account number standardization
    - name: account_number
      transformation: "lambda x: ''.join(filter(str.isalnum, str(x))).upper()"
      
    # EXAMPLE 12: Field to IGNORE in comparison but include in output
    - name: trader_notes
      ignore: true
      
    # EXAMPLE 13: Timestamp field to ignore
    - name: system_timestamp
      ignore: true
      
    # EXAMPLE 14: PnL percentage field
    - name: pnl_percentage
      transformation: "lambda x: float(x.replace('%', '')) / 100 if '%' in str(x) else float(x)"
      tolerance: "1%"
      
    # CONDITION FIELDS FOR CONDITIONAL MAPPING
    # ========================================
    # These fields are used as conditions for conditional mappings below
    - name: market_code
    - name: trade_type
    - name: counterparty
    
    # CONDITIONAL MAPPING EXAMPLES
    # ============================
    # Conditional mappings apply different value mappings based on another field's value
    # This is useful when the same field has different meaning or formats in different contexts
    #
    # Supported condition types:
    # - 'equals' (default): Apply mapping when condition_field equals specific values
    # - 'not_starts_with': Apply mapping when condition_field does NOT start with condition_value
    #
    # For 'not_starts_with', use 'default' as the mapping key and specify condition_value
    
    # EXAMPLE 15: Currency mapping based on counterparty type
    # Map KRA to KRW when counterparty does not start with ABC
    - name: currency1
      conditional_mapping:
        condition_field: counterparty
        condition_type: "not_starts_with"  # Check if counterparty does NOT start with specific value
        condition_value: "ABC"
        mappings:
          # When counterparty does NOT start with "ABC", apply these mappings
          "default":
            "KRA": "KRW"
            # Add other currency mappings as needed
            # "USD": "USD"  # Keep USD as is
            # "EUR": "EUR"  # Keep EUR as is
    
    # EXAMPLE 16: Trade status mapping based on trade type
    # Different trade types use different status codes
    - name: trade_status_conditional
      conditional_mapping:
        condition_field: asset_class  # Base the mapping on asset class
        mappings:
          # For equity trades, use these status mappings
          "EQ":
            "N": "New"
            "PF": "Partially Filled"
            "F": "Filled"
            "C": "Cancelled"
            "R": "Rejected"
          # For fixed income trades, use different status mappings
          "FI":
            "N": "New Order"
            "PF": "Partial Fill"
            "F": "Complete"
            "C": "Void"
            "R": "Declined"
          # For derivatives, use yet another set of mappings
          "DV":
            "N": "Pending"
            "PF": "Executing"
            "F": "Executed"
            "C": "Expired"
            "R": "Failed"
    
    # EXAMPLE 17: Currency formatting based on market
    # Different markets format currency amounts differently
    - name: settlement_currency
      conditional_mapping:
        condition_field: market_code
        mappings:
          # US market uses standard USD codes
          "US":
            "USD": "US Dollar"
            "EUR": "Euro"
            "GBP": "Pound Sterling"
            "CAD": "Canadian Dollar"
          # European market uses different conventions
          "EU":
            "USD": "US-Dollar"
            "EUR": "European Euro"
            "GBP": "British Pound"
            "CHF": "Swiss Franc"
          # Asian market uses local conventions
          "ASIA":
            "USD": "US_Dollar"
            "EUR": "Euro_Currency"
            "JPY": "Japanese Yen"
            "HKD": "Hong Kong Dollar"
    
    # EXAMPLE 18: Settlement instructions based on asset class and market
    - name: settlement_instruction
      conditional_mapping:
        condition_field: asset_class
        mappings:
          "EQ":  # Equity settlements
            "DVP": "Delivery vs Payment"
            "FOP": "Free of Payment"
            "HOLD": "Hold in Account"
            "AUTO": "Auto Settlement"
          "FI":  # Fixed Income settlements
            "DVP": "Bond Settlement DVP"
            "FOP": "Bond Settlement FOP"
            "REPO": "Repurchase Agreement"
            "ROLL": "Rollover Settlement"
          "DV":  # Derivatives settlements
            "CASH": "Cash Settlement"
            "PHYS": "Physical Delivery"
            "NET": "Net Settlement"
            "CLOSE": "Close Out"

# OUTPUT CONFIGURATION
# ===================
output:
  filename: "trading_reconciliation_results"  # Base filename (timestamp added automatically)
  # Results in files like: trading_reconciliation_results_20250624_143022.xlsx
